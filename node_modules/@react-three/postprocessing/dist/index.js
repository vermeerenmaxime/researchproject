import { BlendFunction, BloomEffect, BrightnessContrastEffect, ChromaticAberrationEffect, ColorAverageEffect, ColorDepthEffect, DepthEffect, EffectComposer as EffectComposer$2, RenderPass, NormalPass, EffectPass, DepthOfFieldEffect, DotScreenEffect, GlitchEffect, GlitchMode, GodRaysEffect, GridEffect, HueSaturationEffect, NoiseEffect, OutlineEffect, PixelationEffect, ScanlineEffect, SelectiveBloomEffect, SepiaEffect, SSAOEffect, SMAAPreset, EdgeDetectionMode, SMAAImageLoader, SMAAEffect, TextureEffect, ToneMappingEffect, VignetteEffect, ShockWaveEffect, LUTEffect } from 'postprocessing';
import React, { forwardRef, useMemo, useLayoutEffect, createContext, useRef, useImperativeHandle, useContext, useEffect } from 'react';
import { Vector2, Vector3, TextureLoader, sRGBEncoding, RepeatWrapping } from 'three';
import { useThree, useFrame, useLoader } from '@react-three/fiber';
import { isWebGL2Available } from 'three-stdlib';

const wrapEffect = function (effectImpl, defaultBlendMode) {
  if (defaultBlendMode === void 0) {
    defaultBlendMode = BlendFunction.NORMAL;
  }

  return /*#__PURE__*/forwardRef(function Wrap(_ref, ref) {
    let {
      blendFunction,
      opacity,
      ...props
    } = _ref;
    const effect = useMemo(() => new effectImpl(props), [props]);
    useLayoutEffect(() => {
      effect.blendMode.blendFunction = blendFunction || defaultBlendMode;
      if (opacity !== undefined) effect.blendMode.opacity.value = opacity;
    }, [blendFunction, effect.blendMode, opacity]);
    return /*#__PURE__*/React.createElement("primitive", {
      ref: ref,
      object: effect,
      dispose: null
    });
  });
};
const useVector2 = (props, key) => {
  const vec = props[key];
  return useMemo(() => {
    if (vec instanceof Vector2) {
      return new Vector2().set(vec.x, vec.y);
    } else if (Array.isArray(vec)) {
      const [x, y] = vec;
      return new Vector2().set(x, y);
    }
  }, [vec]);
};

const Bloom = wrapEffect(BloomEffect, BlendFunction.SCREEN);

const BrightnessContrast = wrapEffect(BrightnessContrastEffect);

const ChromaticAberration = /*#__PURE__*/forwardRef(function ChromaticAberration(props, ref) {
  const offset = useVector2(props, 'offset');
  const effect = useMemo(() => new ChromaticAberrationEffect({ ...props,
    offset
  }), [offset, props]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const ColorAverage = /*#__PURE__*/forwardRef(function ColorAverage(_ref, ref) {
  let {
    blendFunction = BlendFunction.NORMAL
  } = _ref;

  /** Because ColorAverage blendFunction is not an object but a number, we have to define a custom prop "blendFunction" */
  const effect = useMemo(() => new ColorAverageEffect(blendFunction), [blendFunction]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const ColorDepth = wrapEffect(ColorDepthEffect);

const Depth = wrapEffect(DepthEffect);

const EffectComposerContext = /*#__PURE__*/createContext(null);
const EffectComposer = /*#__PURE__*/React.memo( /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    camera,
    scene,
    renderPriority = 1,
    autoClear = true,
    depthBuffer,
    disableNormalPass,
    stencilBuffer,
    multisampling = 8,
    frameBufferType
  } = _ref;
  const {
    gl,
    scene: defaultScene,
    camera: defaultCamera,
    size
  } = useThree();
  scene = scene || defaultScene;
  camera = camera || defaultCamera;
  const [composer, normalPass] = useMemo(() => {
    // Initialize composer
    const effectComposer = new EffectComposer$2(gl, {
      depthBuffer,
      stencilBuffer,
      multisampling: isWebGL2Available() ? multisampling : 0,
      frameBufferType
    }); // Add render pass

    effectComposer.addPass(new RenderPass(scene, camera)); // Create normal pass

    const pass = disableNormalPass ? null : new NormalPass(scene, camera);
    if (pass) pass.enabled = false;

    if (pass) {
      effectComposer.addPass(pass);
    }

    return [effectComposer, pass];
  }, [camera, gl, depthBuffer, stencilBuffer, multisampling, frameBufferType, scene, disableNormalPass]);
  useLayoutEffect(() => composer == null ? void 0 : composer.setSize(size.width, size.height), [composer, size]);
  useFrame((_, delta) => void (gl.autoClear = autoClear, composer.render(delta)), renderPriority);
  const group = useRef(null);
  useLayoutEffect(() => {
    let effectPass;

    if (group.current && group.current.__r3f && composer) {
      effectPass = new EffectPass(camera, ...group.current.__r3f.objects);
      composer.addPass(effectPass);
      effectPass.renderToScreen = true;
      if (normalPass) normalPass.enabled = false;
    }

    return () => {
      if (effectPass) composer == null ? void 0 : composer.removePass(effectPass);
      if (normalPass) normalPass.enabled = false;
    };
  }, [composer, children, camera]); // Memoize state, otherwise it would trigger all consumers on every render

  const state = useMemo(() => ({
    composer,
    normalPass,
    camera,
    scene
  }), [composer, normalPass, camera, scene]); // Expose the composer

  useImperativeHandle(ref, () => composer, [composer]);
  return /*#__PURE__*/React.createElement(EffectComposerContext.Provider, {
    value: state
  }, /*#__PURE__*/React.createElement("group", {
    ref: group
  }, children));
}));
var EffectComposer$1 = EffectComposer;

const DepthOfField = /*#__PURE__*/forwardRef(function DepthOfField(_ref, ref) {
  let {
    target,
    depthTexture,
    ...props
  } = _ref;
  const {
    camera
  } = useContext(EffectComposerContext);
  const effect = useMemo(() => new DepthOfFieldEffect(camera, props), [camera, props]);
  useLayoutEffect(() => {
    if (target) {
      const vec = target instanceof Vector3 ? new Vector3().set(target.x, target.y, target.z) : new Vector3().set(target[0], target[1], target[2]);
      effect.target = vec;
    }

    if (depthTexture) effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
  }, [target, depthTexture, effect]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const DotScreen = wrapEffect(DotScreenEffect);

const Glitch = /*#__PURE__*/forwardRef(function Glitch(_ref, ref) {
  let {
    active = true,
    ...props
  } = _ref;
  const delay = useVector2(props, 'delay');
  const duration = useVector2(props, 'duration');
  const strength = useVector2(props, 'strength');
  const effect = useMemo(() => new GlitchEffect({ ...props,
    delay,
    duration,
    strength
  }), [delay, duration, props, strength]);
  useLayoutEffect(() => {
    effect.mode = active ? props.mode || GlitchMode.SPORADIC : GlitchMode.DISABLED;
  }, [active, effect, props.mode]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const GodRays = /*#__PURE__*/forwardRef(function GodRays(props, ref) {
  const {
    camera
  } = useContext(EffectComposerContext);
  const effect = useMemo(() => new GodRaysEffect(camera, props.sun, props), [camera, props]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const Grid = /*#__PURE__*/forwardRef(function Grid(_ref, ref) {
  let {
    size,
    ...props
  } = _ref;
  const effect = useMemo(() => new GridEffect(props), [props]);
  useLayoutEffect(() => {
    if (size) effect.setSize(size.width, size.height);
  }, [effect, size]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const HueSaturation = wrapEffect(HueSaturationEffect);

const Noise = wrapEffect(NoiseEffect, BlendFunction.COLOR_DODGE);

const Outline = /*#__PURE__*/forwardRef(function Outline(_ref, ref) {
  let {
    selection = [],
    selectionLayer = 10,
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay,
    ...props
  } = _ref;
  const {
    scene,
    camera
  } = useContext(EffectComposerContext);
  const effect = useMemo(() => new OutlineEffect(scene, camera, {
    blendFunction,
    patternTexture,
    edgeStrength,
    pulseSpeed,
    visibleEdgeColor,
    hiddenEdgeColor,
    width,
    height,
    kernelSize,
    blur,
    xRay
  }), [blendFunction, blur, camera, edgeStrength, height, hiddenEdgeColor, kernelSize, patternTexture, pulseSpeed, scene, visibleEdgeColor, width, xRay]);
  useEffect(() => {
    effect.clearSelection();
    effect.setSelection(Array.isArray(selection) ? selection.map(ref => ref.current) : [selection.current]);
  }, [effect, selection]);
  useEffect(() => {
    effect.selectionLayer = selectionLayer;
  }, [effect, selectionLayer]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const Pixelation = /*#__PURE__*/forwardRef(function Pixelation(_ref, ref) {
  let {
    granularity = 5
  } = _ref;

  /** Because GlitchEffect granularity is not an object but a number, we have to define a custom prop "granularity" */
  const effect = useMemo(() => new PixelationEffect(granularity), [granularity]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const Scanline = wrapEffect(ScanlineEffect, BlendFunction.OVERLAY);

const addLight = (light, effect) => {
  if (light.current) {
    light.current.layers.enable(effect.selection.layer);
  }
};

const removeLight = (light, effect) => {
  if (light.current) {
    light.current.layers.disable(effect.selection.layer);
  }
};

const SelectiveBloom = /*#__PURE__*/forwardRef(function SelectiveBloom(_ref, ref) {
  let {
    selection = [],
    selectionLayer = 10,
    lights = [],
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize
  } = _ref;

  if (lights.length === 0) {
    console.warn('SelectiveBloom requires lights to work.');
  }

  const {
    scene,
    camera
  } = useContext(EffectComposerContext);
  const effect = useMemo(() => new SelectiveBloomEffect(scene, camera, {
    blendFunction: BlendFunction.SCREEN,
    luminanceThreshold,
    luminanceSmoothing,
    intensity,
    width,
    height,
    kernelSize
  }), [camera, height, intensity, kernelSize, luminanceSmoothing, luminanceThreshold, scene, width]);
  useEffect(() => {
    effect.selection.set(Array.isArray(selection) ? selection.map(ref => ref.current) : [selection.current]);
  }, [effect, selection]);
  useEffect(() => {
    effect.selection.layer = selectionLayer;
  }, [effect, selectionLayer]);
  useEffect(() => {
    lights.forEach(light => addLight(light, effect));
    return () => lights.forEach(light => removeLight(light, effect));
  }, [effect, lights, selectionLayer]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const Sepia = wrapEffect(SepiaEffect);

const SSAO = /*#__PURE__*/forwardRef(function SSAO(props, ref) {
  const {
    camera,
    normalPass
  } = useContext(EffectComposerContext);
  const effect = useMemo(() => {
    if (normalPass === null) {
      console.error('Please enable the NormalPass in the EffectComposer in order to use SSAO.');
      return null;
    }

    return new SSAOEffect(camera, normalPass.renderTarget.texture, {
      blendFunction: BlendFunction.MULTIPLY,
      samples: 30,
      rings: 4,
      distanceThreshold: 1.0,
      distanceFalloff: 0.0,
      rangeThreshold: 0.5,
      rangeFalloff: 0.1,
      luminanceInfluence: 0.9,
      radius: 20,
      scale: 0.5,
      bias: 0.5,
      intensity: 1.0,
      color: null,
      ...props
    });
  }, [camera, normalPass, props]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const SMAA = /*#__PURE__*/forwardRef(function SMAA(_ref, ref) {
  let {
    preset = SMAAPreset.HIGH,
    edgeDetectionMode = EdgeDetectionMode.COLOR
  } = _ref;
  const smaaProps = useLoader(SMAAImageLoader, '');
  const effect = useMemo(() => new SMAAEffect(...smaaProps, preset, edgeDetectionMode), [smaaProps, preset, edgeDetectionMode]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const Texture = /*#__PURE__*/forwardRef(function Texture(_ref, ref) {
  let {
    textureSrc,
    texture,
    ...props
  } = _ref;
  const t = useLoader(TextureLoader, textureSrc);
  useLayoutEffect(() => {
    t.encoding = sRGBEncoding;
    t.wrapS = t.wrapT = RepeatWrapping;
  }, [t]);
  const effect = useMemo(() => new TextureEffect({ ...props,
    texture: t || texture
  }), [props, t, texture]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

const ToneMapping = wrapEffect(ToneMappingEffect);

const Vignette = wrapEffect(VignetteEffect);

const ShockWave = wrapEffect(ShockWaveEffect);

const LUT = /*#__PURE__*/forwardRef(function LUT(_ref, ref) {
  let {
    lut,
    tetrahedralInterpolation,
    ...props
  } = _ref;
  const effect = useMemo(() => new LUTEffect(lut, props), [lut, props]);
  useLayoutEffect(() => {
    if (lut) effect.setLUT(lut);
    if (tetrahedralInterpolation) effect.setTetrahedralInterpolationEnabled(tetrahedralInterpolation);
  }, [effect, lut, tetrahedralInterpolation]);
  return /*#__PURE__*/React.createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

export { Bloom, BrightnessContrast, ChromaticAberration, ColorAverage, ColorDepth, Depth, DepthOfField, DotScreen, EffectComposer$1 as EffectComposer, EffectComposerContext, Glitch, GodRays, Grid, HueSaturation, LUT, Noise, Outline, Pixelation, SMAA, SSAO, Scanline, SelectiveBloom, Sepia, ShockWave, Texture, ToneMapping, Vignette };
