'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var postprocessing = require('postprocessing');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var React = require('react');
var three = require('three');
var _extends = require('@babel/runtime/helpers/extends');
var _construct = require('@babel/runtime/helpers/construct');
var fiber = require('@react-three/fiber');
var threeStdlib = require('three-stdlib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var _construct__default = /*#__PURE__*/_interopDefaultLegacy(_construct);

var _excluded$6 = ["blendFunction", "opacity"];
var wrapEffect = function wrapEffect(effectImpl, defaultBlendMode) {
  if (defaultBlendMode === void 0) {
    defaultBlendMode = postprocessing.BlendFunction.NORMAL;
  }

  return /*#__PURE__*/React.forwardRef(function Wrap(_ref, ref) {
    var blendFunction = _ref.blendFunction,
        opacity = _ref.opacity,
        props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$6);

    var effect = React.useMemo(function () {
      return new effectImpl(props);
    }, [props]);
    React.useLayoutEffect(function () {
      effect.blendMode.blendFunction = blendFunction || defaultBlendMode;
      if (opacity !== undefined) effect.blendMode.opacity.value = opacity;
    }, [blendFunction, effect.blendMode, opacity]);
    return /*#__PURE__*/React__default["default"].createElement("primitive", {
      ref: ref,
      object: effect,
      dispose: null
    });
  });
};
var useVector2 = function useVector2(props, key) {
  var vec = props[key];
  return React.useMemo(function () {
    if (vec instanceof three.Vector2) {
      return new three.Vector2().set(vec.x, vec.y);
    } else if (Array.isArray(vec)) {
      var x = vec[0],
          y = vec[1];
      return new three.Vector2().set(x, y);
    }
  }, [vec]);
};

var Bloom = wrapEffect(postprocessing.BloomEffect, postprocessing.BlendFunction.SCREEN);

var BrightnessContrast = wrapEffect(postprocessing.BrightnessContrastEffect);

var ChromaticAberration = /*#__PURE__*/React.forwardRef(function ChromaticAberration(props, ref) {
  var offset = useVector2(props, 'offset');
  var effect = React.useMemo(function () {
    return new postprocessing.ChromaticAberrationEffect(_extends__default["default"]({}, props, {
      offset: offset
    }));
  }, [offset, props]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var ColorAverage = /*#__PURE__*/React.forwardRef(function ColorAverage(_ref, ref) {
  var _ref$blendFunction = _ref.blendFunction,
      blendFunction = _ref$blendFunction === void 0 ? postprocessing.BlendFunction.NORMAL : _ref$blendFunction;

  /** Because ColorAverage blendFunction is not an object but a number, we have to define a custom prop "blendFunction" */
  var effect = React.useMemo(function () {
    return new postprocessing.ColorAverageEffect(blendFunction);
  }, [blendFunction]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var ColorDepth = wrapEffect(postprocessing.ColorDepthEffect);

var Depth = wrapEffect(postprocessing.DepthEffect);

var EffectComposerContext = /*#__PURE__*/React.createContext(null);
var EffectComposer = /*#__PURE__*/React__default["default"].memo( /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      camera = _ref.camera,
      scene = _ref.scene,
      _ref$renderPriority = _ref.renderPriority,
      renderPriority = _ref$renderPriority === void 0 ? 1 : _ref$renderPriority,
      _ref$autoClear = _ref.autoClear,
      autoClear = _ref$autoClear === void 0 ? true : _ref$autoClear,
      depthBuffer = _ref.depthBuffer,
      disableNormalPass = _ref.disableNormalPass,
      stencilBuffer = _ref.stencilBuffer,
      _ref$multisampling = _ref.multisampling,
      multisampling = _ref$multisampling === void 0 ? 8 : _ref$multisampling,
      frameBufferType = _ref.frameBufferType;

  var _useThree = fiber.useThree(),
      gl = _useThree.gl,
      defaultScene = _useThree.scene,
      defaultCamera = _useThree.camera,
      size = _useThree.size;

  scene = scene || defaultScene;
  camera = camera || defaultCamera;

  var _useMemo = React.useMemo(function () {
    // Initialize composer
    var effectComposer = new postprocessing.EffectComposer(gl, {
      depthBuffer: depthBuffer,
      stencilBuffer: stencilBuffer,
      multisampling: threeStdlib.isWebGL2Available() ? multisampling : 0,
      frameBufferType: frameBufferType
    }); // Add render pass

    // Add render pass
    effectComposer.addPass(new postprocessing.RenderPass(scene, camera)); // Create normal pass

    // Create normal pass
    var pass = disableNormalPass ? null : new postprocessing.NormalPass(scene, camera);
    if (pass) pass.enabled = false;

    if (pass) {
      effectComposer.addPass(pass);
    }

    return [effectComposer, pass];
  }, [camera, gl, depthBuffer, stencilBuffer, multisampling, frameBufferType, scene, disableNormalPass]),
      composer = _useMemo[0],
      normalPass = _useMemo[1];

  React.useLayoutEffect(function () {
    return composer == null ? void 0 : composer.setSize(size.width, size.height);
  }, [composer, size]);
  fiber.useFrame(function (_, delta) {
    return void (gl.autoClear = autoClear, composer.render(delta));
  }, renderPriority);
  var group = React.useRef(null);
  React.useLayoutEffect(function () {
    var effectPass;

    if (group.current && group.current.__r3f && composer) {
      effectPass = _construct__default["default"](postprocessing.EffectPass, [camera].concat(group.current.__r3f.objects));
      composer.addPass(effectPass);
      effectPass.renderToScreen = true;
      if (normalPass) normalPass.enabled = false;
    }

    return function () {
      if (effectPass) composer == null ? void 0 : composer.removePass(effectPass);
      if (normalPass) normalPass.enabled = false;
    };
  }, [composer, children, camera]); // Memoize state, otherwise it would trigger all consumers on every render

  var state = React.useMemo(function () {
    return {
      composer: composer,
      normalPass: normalPass,
      camera: camera,
      scene: scene
    };
  }, [composer, normalPass, camera, scene]); // Expose the composer

  React.useImperativeHandle(ref, function () {
    return composer;
  }, [composer]);
  return /*#__PURE__*/React__default["default"].createElement(EffectComposerContext.Provider, {
    value: state
  }, /*#__PURE__*/React__default["default"].createElement("group", {
    ref: group
  }, children));
}));
var EffectComposer$1 = EffectComposer;

var _excluded$5 = ["target", "depthTexture"];
var DepthOfField = /*#__PURE__*/React.forwardRef(function DepthOfField(_ref, ref) {
  var target = _ref.target,
      depthTexture = _ref.depthTexture,
      props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$5);

  var _useContext = React.useContext(EffectComposerContext),
      camera = _useContext.camera;

  var effect = React.useMemo(function () {
    return new postprocessing.DepthOfFieldEffect(camera, props);
  }, [camera, props]);
  React.useLayoutEffect(function () {
    if (target) {
      var vec = target instanceof three.Vector3 ? new three.Vector3().set(target.x, target.y, target.z) : new three.Vector3().set(target[0], target[1], target[2]);
      effect.target = vec;
    }

    if (depthTexture) effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
  }, [target, depthTexture, effect]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var DotScreen = wrapEffect(postprocessing.DotScreenEffect);

var _excluded$4 = ["active"];
var Glitch = /*#__PURE__*/React.forwardRef(function Glitch(_ref, ref) {
  var _ref$active = _ref.active,
      active = _ref$active === void 0 ? true : _ref$active,
      props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$4);

  var delay = useVector2(props, 'delay');
  var duration = useVector2(props, 'duration');
  var strength = useVector2(props, 'strength');
  var effect = React.useMemo(function () {
    return new postprocessing.GlitchEffect(_extends__default["default"]({}, props, {
      delay: delay,
      duration: duration,
      strength: strength
    }));
  }, [delay, duration, props, strength]);
  React.useLayoutEffect(function () {
    effect.mode = active ? props.mode || postprocessing.GlitchMode.SPORADIC : postprocessing.GlitchMode.DISABLED;
  }, [active, effect, props.mode]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var GodRays = /*#__PURE__*/React.forwardRef(function GodRays(props, ref) {
  var _useContext = React.useContext(EffectComposerContext),
      camera = _useContext.camera;

  var effect = React.useMemo(function () {
    return new postprocessing.GodRaysEffect(camera, props.sun, props);
  }, [camera, props]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var _excluded$3 = ["size"];
var Grid = /*#__PURE__*/React.forwardRef(function Grid(_ref, ref) {
  var size = _ref.size,
      props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$3);

  var effect = React.useMemo(function () {
    return new postprocessing.GridEffect(props);
  }, [props]);
  React.useLayoutEffect(function () {
    if (size) effect.setSize(size.width, size.height);
  }, [effect, size]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var HueSaturation = wrapEffect(postprocessing.HueSaturationEffect);

var Noise = wrapEffect(postprocessing.NoiseEffect, postprocessing.BlendFunction.COLOR_DODGE);

var _excluded$2 = ["selection", "selectionLayer", "blendFunction", "patternTexture", "edgeStrength", "pulseSpeed", "visibleEdgeColor", "hiddenEdgeColor", "width", "height", "kernelSize", "blur", "xRay"];
var Outline = /*#__PURE__*/React.forwardRef(function Outline(_ref, ref) {
  var _ref$selection = _ref.selection,
      selection = _ref$selection === void 0 ? [] : _ref$selection,
      _ref$selectionLayer = _ref.selectionLayer,
      selectionLayer = _ref$selectionLayer === void 0 ? 10 : _ref$selectionLayer,
      blendFunction = _ref.blendFunction,
      patternTexture = _ref.patternTexture,
      edgeStrength = _ref.edgeStrength,
      pulseSpeed = _ref.pulseSpeed,
      visibleEdgeColor = _ref.visibleEdgeColor,
      hiddenEdgeColor = _ref.hiddenEdgeColor,
      width = _ref.width,
      height = _ref.height,
      kernelSize = _ref.kernelSize,
      blur = _ref.blur,
      xRay = _ref.xRay;
      _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$2);

  var _useContext = React.useContext(EffectComposerContext),
      scene = _useContext.scene,
      camera = _useContext.camera;

  var effect = React.useMemo(function () {
    return new postprocessing.OutlineEffect(scene, camera, {
      blendFunction: blendFunction,
      patternTexture: patternTexture,
      edgeStrength: edgeStrength,
      pulseSpeed: pulseSpeed,
      visibleEdgeColor: visibleEdgeColor,
      hiddenEdgeColor: hiddenEdgeColor,
      width: width,
      height: height,
      kernelSize: kernelSize,
      blur: blur,
      xRay: xRay
    });
  }, [blendFunction, blur, camera, edgeStrength, height, hiddenEdgeColor, kernelSize, patternTexture, pulseSpeed, scene, visibleEdgeColor, width, xRay]);
  React.useEffect(function () {
    effect.clearSelection();
    effect.setSelection(Array.isArray(selection) ? selection.map(function (ref) {
      return ref.current;
    }) : [selection.current]);
  }, [effect, selection]);
  React.useEffect(function () {
    effect.selectionLayer = selectionLayer;
  }, [effect, selectionLayer]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var Pixelation = /*#__PURE__*/React.forwardRef(function Pixelation(_ref, ref) {
  var _ref$granularity = _ref.granularity,
      granularity = _ref$granularity === void 0 ? 5 : _ref$granularity;

  /** Because GlitchEffect granularity is not an object but a number, we have to define a custom prop "granularity" */
  var effect = React.useMemo(function () {
    return new postprocessing.PixelationEffect(granularity);
  }, [granularity]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var Scanline = wrapEffect(postprocessing.ScanlineEffect, postprocessing.BlendFunction.OVERLAY);

var addLight = function addLight(light, effect) {
  if (light.current) {
    light.current.layers.enable(effect.selection.layer);
  }
};

var removeLight = function removeLight(light, effect) {
  if (light.current) {
    light.current.layers.disable(effect.selection.layer);
  }
};

var SelectiveBloom = /*#__PURE__*/React.forwardRef(function SelectiveBloom(_ref, ref) {
  var _ref$selection = _ref.selection,
      selection = _ref$selection === void 0 ? [] : _ref$selection,
      _ref$selectionLayer = _ref.selectionLayer,
      selectionLayer = _ref$selectionLayer === void 0 ? 10 : _ref$selectionLayer,
      _ref$lights = _ref.lights,
      lights = _ref$lights === void 0 ? [] : _ref$lights,
      luminanceThreshold = _ref.luminanceThreshold,
      luminanceSmoothing = _ref.luminanceSmoothing,
      intensity = _ref.intensity,
      width = _ref.width,
      height = _ref.height,
      kernelSize = _ref.kernelSize;

  if (lights.length === 0) {
    console.warn('SelectiveBloom requires lights to work.');
  }

  var _useContext = React.useContext(EffectComposerContext),
      scene = _useContext.scene,
      camera = _useContext.camera;

  var effect = React.useMemo(function () {
    return new postprocessing.SelectiveBloomEffect(scene, camera, {
      blendFunction: postprocessing.BlendFunction.SCREEN,
      luminanceThreshold: luminanceThreshold,
      luminanceSmoothing: luminanceSmoothing,
      intensity: intensity,
      width: width,
      height: height,
      kernelSize: kernelSize
    });
  }, [camera, height, intensity, kernelSize, luminanceSmoothing, luminanceThreshold, scene, width]);
  React.useEffect(function () {
    effect.selection.set(Array.isArray(selection) ? selection.map(function (ref) {
      return ref.current;
    }) : [selection.current]);
  }, [effect, selection]);
  React.useEffect(function () {
    effect.selection.layer = selectionLayer;
  }, [effect, selectionLayer]);
  React.useEffect(function () {
    lights.forEach(function (light) {
      return addLight(light, effect);
    });
    return function () {
      return lights.forEach(function (light) {
        return removeLight(light, effect);
      });
    };
  }, [effect, lights, selectionLayer]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var Sepia = wrapEffect(postprocessing.SepiaEffect);

var SSAO = /*#__PURE__*/React.forwardRef(function SSAO(props, ref) {
  var _useContext = React.useContext(EffectComposerContext),
      camera = _useContext.camera,
      normalPass = _useContext.normalPass;

  var effect = React.useMemo(function () {
    if (normalPass === null) {
      console.error('Please enable the NormalPass in the EffectComposer in order to use SSAO.');
      return null;
    }

    return new postprocessing.SSAOEffect(camera, normalPass.renderTarget.texture, _extends__default["default"]({
      blendFunction: postprocessing.BlendFunction.MULTIPLY,
      samples: 30,
      rings: 4,
      distanceThreshold: 1.0,
      distanceFalloff: 0.0,
      rangeThreshold: 0.5,
      rangeFalloff: 0.1,
      luminanceInfluence: 0.9,
      radius: 20,
      scale: 0.5,
      bias: 0.5,
      intensity: 1.0,
      color: null
    }, props));
  }, [camera, normalPass, props]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var SMAA = /*#__PURE__*/React.forwardRef(function SMAA(_ref, ref) {
  var _ref$preset = _ref.preset,
      preset = _ref$preset === void 0 ? postprocessing.SMAAPreset.HIGH : _ref$preset,
      _ref$edgeDetectionMod = _ref.edgeDetectionMode,
      edgeDetectionMode = _ref$edgeDetectionMod === void 0 ? postprocessing.EdgeDetectionMode.COLOR : _ref$edgeDetectionMod;
  var smaaProps = fiber.useLoader(postprocessing.SMAAImageLoader, '');
  var effect = React.useMemo(function () {
    return _construct__default["default"](postprocessing.SMAAEffect, smaaProps.concat([preset, edgeDetectionMode]));
  }, [smaaProps, preset, edgeDetectionMode]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var _excluded$1 = ["textureSrc", "texture"];
var Texture = /*#__PURE__*/React.forwardRef(function Texture(_ref, ref) {
  var textureSrc = _ref.textureSrc,
      texture = _ref.texture,
      props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded$1);

  var t = fiber.useLoader(three.TextureLoader, textureSrc);
  React.useLayoutEffect(function () {
    t.encoding = three.sRGBEncoding;
    t.wrapS = t.wrapT = three.RepeatWrapping;
  }, [t]);
  var effect = React.useMemo(function () {
    return new postprocessing.TextureEffect(_extends__default["default"]({}, props, {
      texture: t || texture
    }));
  }, [props, t, texture]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

var ToneMapping = wrapEffect(postprocessing.ToneMappingEffect);

var Vignette = wrapEffect(postprocessing.VignetteEffect);

var ShockWave = wrapEffect(postprocessing.ShockWaveEffect);

var _excluded = ["lut", "tetrahedralInterpolation"];
var LUT = /*#__PURE__*/React.forwardRef(function LUT(_ref, ref) {
  var lut = _ref.lut,
      tetrahedralInterpolation = _ref.tetrahedralInterpolation,
      props = _objectWithoutPropertiesLoose__default["default"](_ref, _excluded);

  var effect = React.useMemo(function () {
    return new postprocessing.LUTEffect(lut, props);
  }, [lut, props]);
  React.useLayoutEffect(function () {
    if (lut) effect.setLUT(lut);
    if (tetrahedralInterpolation) effect.setTetrahedralInterpolationEnabled(tetrahedralInterpolation);
  }, [effect, lut, tetrahedralInterpolation]);
  return /*#__PURE__*/React__default["default"].createElement("primitive", {
    ref: ref,
    object: effect,
    dispose: null
  });
});

exports.Bloom = Bloom;
exports.BrightnessContrast = BrightnessContrast;
exports.ChromaticAberration = ChromaticAberration;
exports.ColorAverage = ColorAverage;
exports.ColorDepth = ColorDepth;
exports.Depth = Depth;
exports.DepthOfField = DepthOfField;
exports.DotScreen = DotScreen;
exports.EffectComposer = EffectComposer$1;
exports.EffectComposerContext = EffectComposerContext;
exports.Glitch = Glitch;
exports.GodRays = GodRays;
exports.Grid = Grid;
exports.HueSaturation = HueSaturation;
exports.LUT = LUT;
exports.Noise = Noise;
exports.Outline = Outline;
exports.Pixelation = Pixelation;
exports.SMAA = SMAA;
exports.SSAO = SSAO;
exports.Scanline = Scanline;
exports.SelectiveBloom = SelectiveBloom;
exports.Sepia = Sepia;
exports.ShockWave = ShockWave;
exports.Texture = Texture;
exports.ToneMapping = ToneMapping;
exports.Vignette = Vignette;
